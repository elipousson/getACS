% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/xwalk.R
\name{make_area_xwalk}
\alias{make_area_xwalk}
\alias{use_area_xwalk}
\title{Make and use crosswalk data based on U.S. Census block-level weights for U.S.
Census tracts and non-Census geographic areas}
\usage{
make_area_xwalk(
  area,
  block_xwalk = NULL,
  state = NULL,
  county = NULL,
  year = 2020,
  name_col = "name",
  weight_col = "HOUSING20",
  geoid_col = "GEOID",
  tract_col = "TRACTCE20",
  by = c(TRACTCE20 = "TRACTCE"),
  suffix = c("_block", "_tract"),
  digits = 2,
  add_coverage = TRUE,
  ...
)

use_area_xwalk(
  data,
  area_xwalk,
  name_col = "NAME",
  geoid_col = "GEOID",
  suffix = c("_area", ""),
  weight_col = "HOUSING20",
  geography = "area",
  digits = 0,
  perc = TRUE,
  ...
)
}
\arguments{
\item{area}{A sf object with an arbitrary geography overlapping with the
block_xwalk. Required. If area only partly overlaps with block_xwalk,
add_coverage should be set to \code{TRUE} (default).}

\item{block_xwalk}{Block-tract crosswalk sf object. If \code{NULL}, state is
required to create a crosswalk using \code{\link[=make_block_xwalk]{make_block_xwalk()}}}

\item{state}{The two-digit FIPS code (string) of the state you want. Can also
be state name or state abbreviation.}

\item{county}{The three-digit FIPS code (string) of the county you'd like to
subset for, or a vector of FIPS codes if you desire multiple counties.
Can also be a county name or vector of names.}

\item{year}{the data year; defaults to 2021}

\item{name_col}{Name column in area.}

\item{weight_col}{Column name to use for weighting}

\item{geoid_col, tract_col}{GeoID for Census tract and Census tract ID column
in block_xwalk}

\item{by}{A join specification created with \code{\link[dplyr:join_by]{join_by()}}, or a character
vector of variables to join by.

If \code{NULL}, the default, \verb{*_join()} will perform a natural join, using all
variables in common across \code{x} and \code{y}. A message lists the variables so
that you can check they're correct; suppress the message by supplying \code{by}
explicitly.

To join on different variables between \code{x} and \code{y}, use a \code{\link[dplyr:join_by]{join_by()}}
specification. For example, \code{join_by(a == b)} will match \code{x$a} to \code{y$b}.

To join by multiple variables, use a \code{\link[dplyr:join_by]{join_by()}} specification with
multiple expressions. For example, \code{join_by(a == b, c == d)} will match
\code{x$a} to \code{y$b} and \code{x$c} to \code{y$d}. If the column names are the same between
\code{x} and \code{y}, you can shorten this by listing only the variable names, like
\code{join_by(a, c)}.

\code{\link[dplyr:join_by]{join_by()}} can also be used to perform inequality, rolling, and overlap
joins. See the documentation at \link[dplyr:join_by]{?join_by} for details on
these types of joins.

For simple equality joins, you can alternatively specify a character vector
of variable names to join by. For example, \code{by = c("a", "b")} joins \code{x$a}
to \code{y$a} and \code{x$b} to \code{y$b}. If variable names differ between \code{x} and \code{y},
use a named character vector like \code{by = c("x_a" = "y_a", "x_b" = "y_b")}.

To perform a cross-join, generating all combinations of \code{x} and \code{y}, see
\code{\link[dplyr:cross_join]{cross_join()}}.}

\item{suffix}{If there are non-joined duplicate variables in \code{x} and
\code{y}, these suffixes will be added to the output to disambiguate them.
Should be a character vector of length 2.}

\item{digits}{Digits to use for percent share of weight value.}

\item{add_coverage}{If \code{TRUE} (default), it is assumed that area does not
cover the full extent of the block_xwalk and an additional feature is added
with the difference between the unioned area geometry and unioned
block_xwalk geometry. This additional coverage ensures that blocks are
accurately assigned to this alternate geography but it is excluded from the
returned data frame.}

\item{...}{arguments to be passed to internal function \code{load_tiger}, which is not exported. See Additional Arguments.}

\item{data}{A data frame downloaded with \code{\link[tidycensus:get_acs]{tidycensus::get_acs()}}.}

\item{area_xwalk}{A area crosswalk data frame created with
\code{\link[=make_area_xwalk]{make_area_xwalk()}}. Required for \code{\link[=use_area_xwalk]{use_area_xwalk()}}.}

\item{geography}{A character string used as general description for area
geography type. Defaults to "area" but typical values could include
"neighborhood", "planning district", or "service area".}

\item{perc}{If \code{TRUE} (default), use the denominator column ID to calculate
each estimate as a percent share of the denominator value and use
\code{\link[tidycensus:moe_prop]{tidycensus::moe_prop()}} to calculate a new margin of error for the percent
estimate.}
}
\description{
\code{make_area_xwalk()} creates a crosswalk data frame based on the \code{weight_col}
parameter (if \code{year = 2020}, use "POP20" for population, "HOUSING20" for
households, or "ALAND20" for land area). Using this function with other
years, requires users to add population data to the block_xwalk as the
\code{\link[tigris:blocks]{tigris::blocks()}} function only includes population and household count data
for the 2020 year. This function has also not been tested when areas include
overlapping geometry and the results may be invalid for those overlapping
areas if that is the case.
}
\details{
Using an area crosswalk

After creating an area crosswalk with \code{\link[=make_area_xwalk]{make_area_xwalk()}}, you can pass the
crosswalk to \code{\link[=use_area_xwalk]{use_area_xwalk()}} along with a data frame from
\code{\link[tidycensus:get_acs]{tidycensus::get_acs()}} or \code{\link[=get_acs_tables]{get_acs_tables()}}. At a minimum, the data must
have a column with the same name as geoid_col along with columns named
"variable", "estimate", and "moe". Please note that this approach to
aggregation does \emph{not} work well if your data contains "jam" values, e.g. the
substitution of 0 for "1939 or older" for the Median Year Built variable.
Ideally, the weight used for aggregation should be based on household counts
when aggregating a household-level variable and population counts when
aggregating a individual-level variable.
}
